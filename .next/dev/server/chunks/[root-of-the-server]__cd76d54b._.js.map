{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/api/upload-product-image/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { writeFile, unlink, access } from 'fs/promises';\nimport path from 'path';\n\nexport async function POST(req: NextRequest) {\n  try {\n    const formData = await req.formData();\n    const file = formData.get('file') as File;\n    const productName = formData.get('productName') as string;\n    const productId = formData.get('productId') as string;\n\n    if (!file) {\n      return NextResponse.json(\n        { error: 'Nenhum arquivo enviado' },\n        { status: 400 }\n      );\n    }\n\n    // Validate file type\n    if (!file.type.startsWith('image/')) {\n      return NextResponse.json(\n        { error: 'Por favor, envie uma imagem' },\n        { status: 400 }\n      );\n    }\n\n    // Generate filename based on product name or ID\n    let baseName = '';\n    if (productName && productName.trim() !== '') {\n      // Sanitize name: remove special chars, replace spaces with underscores\n      baseName = productName\n        .toLowerCase()\n        .normalize('NFD')\n        .replace(/[\\u0300-\\u036f]/g, '') // Remove accents\n        .replace(/[^a-z0-9\\s]/g, '') // Keep only alphanumeric and spaces\n        .replace(/\\s+/g, '_') // Replace spaces with underscores\n        .substring(0, 50); // Limit length\n    } else if (productId) {\n      baseName = productId;\n    } else {\n      // Fallback to timestamp if neither name nor ID\n      baseName = `produto_${Date.now()}`;\n    }\n\n    const fileExtension = file.name.split('.').pop() || 'jpg';\n    let fileName = `${baseName}.${fileExtension}`;\n    \n    // If file exists, add a number suffix to make it unique\n    const uploadDir = path.join(process.cwd(), 'public', 'fotos', 'produtos');\n    let filePath = path.join(uploadDir, fileName);\n    let counter = 1;\n    \n    // Check if file exists and create unique name if needed\n    while (true) {\n      try {\n        await access(filePath);\n        // File exists, create new name\n        fileName = `${baseName}_${counter}.${fileExtension}`;\n        filePath = path.join(uploadDir, fileName);\n        counter++;\n      } catch {\n        // File doesn't exist, we can use this name\n        break;\n      }\n    }\n\n    // Convert file to buffer\n    const bytes = await file.arrayBuffer();\n    const buffer = Buffer.from(bytes);\n\n    // Save to public/fotos/produtos\n    await writeFile(filePath, buffer);\n\n    // Return the public URL path\n    const publicPath = `/fotos/produtos/${fileName}`;\n\n    return NextResponse.json({\n      url: publicPath,\n      fileName: fileName,\n      message: 'Imagem salva com sucesso'\n    });\n\n  } catch (error) {\n    console.error('Erro ao fazer upload da imagem:', error);\n    return NextResponse.json(\n      { error: 'Erro ao fazer upload da imagem' },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function DELETE(req: NextRequest) {\n  try {\n    const { searchParams } = new URL(req.url);\n    const imagePath = searchParams.get('path');\n\n    if (!imagePath || !imagePath.startsWith('/fotos/produtos/')) {\n      return NextResponse.json(\n        { error: 'Caminho de imagem inv√°lido' },\n        { status: 400 }\n      );\n    }\n\n    const filePath = path.join(process.cwd(), 'public', imagePath);\n\n    try {\n      await access(filePath);\n      await unlink(filePath);\n    } catch {\n      // File doesn't exist, that's ok\n    }\n\n    return NextResponse.json({\n      message: 'Imagem removida com sucesso'\n    });\n  } catch (error) {\n    console.error('Erro ao remover imagem:', error);\n    return NextResponse.json(\n      { error: 'Erro ao remover imagem' },\n      { status: 500 }\n    );\n  }\n}"],"names":[],"mappings":"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","debugId":null}}]
}