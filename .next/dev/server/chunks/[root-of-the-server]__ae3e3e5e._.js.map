{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/api/printers/discover/route.ts"],"sourcesContent":["// API para descobrir impressoras na rede local e conectadas via USB/Serial\nimport { NextResponse } from \"next/server\";\nimport * as os from 'os';\nimport * as net from 'net';\n\n// Portas comuns para impressoras t√©rmicas e de rede\nconst THERMAL_PRINTER_PORTS = [\n  9100,  // Porta padr√£o para impressoras t√©rmicas de rede (RAW)\n  515,   // LPR/LPD protocol\n  631,   // IPP (Internet Printing Protocol)\n  3910,  // Porta alternativa para impressoras t√©rmicas\n  9101,  // Porta alternativa\n  9102,  // Porta alternativa\n  9103,  // Porta alternativa\n  4000,  // Algumas Epson\n  6001,  // Algumas Bematech\n  8000,  // Algumas Daruma\n];\n\n// Subnets comuns em redes dom√©sticas e empresariais\nconst COMMON_SUBNETS = [\n  '192.168.0.',\n  '192.168.1.',\n  '192.168.86.',  // Subnet espec√≠fica do usu√°rio\n  '192.168.100.',\n  '192.168.2.',\n  '192.168.10.',\n  '192.168.11.',\n  '10.0.0.',\n  '10.0.1.',\n  '172.16.0.',\n  '172.31.121.' // Subnet do Replit\n];\n\n// Verificar se um IP responde em uma porta espec√≠fica\nasync function checkPort(ip: string, port: number, timeout: number = 300): Promise<boolean> {\n  return new Promise((resolve) => {\n    const socket = new net.Socket();\n    let resolved = false;\n    \n    const timeoutHandle = setTimeout(() => {\n      if (!resolved) {\n        resolved = true;\n        socket.destroy();\n        resolve(false);\n      }\n    }, timeout);\n    \n    socket.setTimeout(timeout);\n    \n    socket.on('connect', () => {\n      if (!resolved) {\n        resolved = true;\n        clearTimeout(timeoutHandle);\n        socket.destroy();\n        resolve(true);\n      }\n    });\n    \n    socket.on('error', () => {\n      if (!resolved) {\n        resolved = true;\n        clearTimeout(timeoutHandle);\n        socket.destroy();\n        resolve(false);\n      }\n    });\n    \n    socket.on('timeout', () => {\n      if (!resolved) {\n        resolved = true;\n        clearTimeout(timeoutHandle);\n        socket.destroy();\n        resolve(false);\n      }\n    });\n    \n    try {\n      socket.connect(port, ip);\n    } catch (error) {\n      if (!resolved) {\n        resolved = true;\n        clearTimeout(timeoutHandle);\n        resolve(false);\n      }\n    }\n  });\n}\n\n// Obter informa√ß√µes da impressora via ESC/POS\nasync function getPrinterInfo(ip: string, port: number): Promise<any> {\n  return new Promise((resolve) => {\n    const socket = new net.Socket();\n    let resolved = false;\n    \n    const timeout = setTimeout(() => {\n      if (!resolved) {\n        resolved = true;\n        socket.destroy();\n        resolve({ model: 'Impressora T√©rmica de Rede' });\n      }\n    }, 1500);\n    \n    socket.setTimeout(1500);\n    \n    socket.on('connect', () => {\n      // Enviar comandos ESC/POS para identifica√ß√£o\n      const commands = [\n        Buffer.from([0x1D, 0x49, 0x01]), // GS I 1 - Printer ID\n        Buffer.from([0x1D, 0x49, 0x02]), // GS I 2 - Printer type\n        Buffer.from([0x1D, 0x49, 0x03]), // GS I 3 - ROM version\n      ];\n      \n      commands.forEach(cmd => socket.write(cmd));\n      \n      // Aguardar resposta\n      setTimeout(() => {\n        if (!resolved) {\n          resolved = true;\n          clearTimeout(timeout);\n          socket.destroy();\n          resolve({ model: 'Impressora T√©rmica ESC/POS' });\n        }\n      }, 500);\n    });\n    \n    socket.on('data', (data: Buffer) => {\n      if (!resolved) {\n        resolved = true;\n        clearTimeout(timeout);\n        socket.destroy();\n        \n        // Tentar identificar o modelo pela resposta\n        const response = data.toString('utf8');\n        let model = 'Impressora T√©rmica';\n        \n        if (response.includes('EPSON') || response.includes('TM-')) {\n          model = 'Epson TM Series';\n        } else if (response.includes('BEMATECH') || response.includes('MP-')) {\n          model = 'Bematech MP Series';\n        } else if (response.includes('ELGIN') || response.includes('I9')) {\n          model = 'Elgin I Series';\n        } else if (response.includes('DARUMA') || response.includes('DR')) {\n          model = 'Daruma DR Series';\n        } else if (response.includes('STAR') || response.includes('TSP')) {\n          model = 'Star TSP Series';\n        } else if (response.includes('CITIZEN')) {\n          model = 'Citizen CT Series';\n        } else if (response.includes('SWEDA')) {\n          model = 'Sweda SI Series';\n        } else if (response.includes('DIEBOLD')) {\n          model = 'Diebold IM Series';\n        } else if (response.includes('TANCA')) {\n          model = 'Tanca TP Series';\n        } else if (response.includes('JETWAY')) {\n          model = 'Jetway JP Series';\n        }\n        \n        resolve({ model, rawResponse: response });\n      }\n    });\n    \n    socket.on('error', () => {\n      if (!resolved) {\n        resolved = true;\n        clearTimeout(timeout);\n        resolve({ model: 'Impressora de Rede' });\n      }\n    });\n    \n    socket.on('timeout', () => {\n      if (!resolved) {\n        resolved = true;\n        clearTimeout(timeout);\n        socket.destroy();\n        resolve({ model: 'Impressora de Rede' });\n      }\n    });\n    \n    try {\n      socket.connect(port, ip);\n    } catch (error) {\n      if (!resolved) {\n        resolved = true;\n        clearTimeout(timeout);\n        resolve({ model: 'Impressora de Rede' });\n      }\n    }\n  });\n}\n\n// Obter subnets locais do sistema\nfunction getLocalSubnets(): string[] {\n  const interfaces = os.networkInterfaces();\n  const subnets = new Set<string>();\n  \n  // Adicionar subnets do sistema\n  for (const [name, addresses] of Object.entries(interfaces)) {\n    if (!addresses) continue;\n    \n    for (const addr of addresses) {\n      // Apenas IPv4 e n√£o loopback\n      if (addr.family === 'IPv4' && !addr.internal) {\n        // Extrair subnet (primeiros 3 octetos)\n        const parts = addr.address.split('.');\n        if (parts.length === 4) {\n          subnets.add(`${parts[0]}.${parts[1]}.${parts[2]}.`);\n        }\n      }\n    }\n  }\n  \n  // Sempre incluir subnets comuns\n  COMMON_SUBNETS.forEach(subnet => subnets.add(subnet));\n  \n  return Array.from(subnets);\n}\n\n// Descobrir impressoras em uma subnet\nasync function scanSubnet(subnet: string, quickScan: boolean = false): Promise<any[]> {\n  const foundPrinters: any[] = [];\n  const promises: Promise<void>[] = [];\n  \n  console.log(`üîç Escaneando subnet ${subnet}0/24...`);\n  \n  // Range de IPs para escanear\n  let ipsToScan: number[] = [];\n  \n  if (quickScan) {\n    // Quick scan: IPs comuns para impressoras\n    ipsToScan = [1, 2, 10, 20, 30, 50, 100, 101, 102, 103, 110, 150, 190, 191, 192, 200, 250, 254];\n  } else {\n    // Full scan: todos os IPs\n    for (let i = 1; i <= 254; i++) {\n      ipsToScan.push(i);\n    }\n  }\n  \n  for (const i of ipsToScan) {\n    const ip = `${subnet}${i}`;\n    \n    promises.push(\n      (async () => {\n        // Testar apenas porta 9100 primeiro (mais comum)\n        const isOpen9100 = await checkPort(ip, 9100, quickScan ? 150 : 250);\n        if (isOpen9100) {\n          console.log(`‚úÖ Impressora encontrada em ${ip}:9100`);\n          \n          // Tentar obter informa√ß√µes da impressora\n          const info = await getPrinterInfo(ip, 9100);\n          \n          foundPrinters.push({\n            ip,\n            port: 9100,\n            name: `Impressora ${ip}`,\n            model: info?.model || 'Impressora T√©rmica',\n            type: 'network',\n            status: 'online',\n            protocol: 'RAW',\n            discovered: true\n          });\n        } else if (!quickScan) {\n          // Se n√£o for quick scan, testar outras portas\n          for (const port of [515, 631, 3910]) {\n            const isOpen = await checkPort(ip, port, 150);\n            if (isOpen) {\n              console.log(`‚úÖ Impressora encontrada em ${ip}:${port}`);\n              \n              foundPrinters.push({\n                ip,\n                port,\n                name: `Impressora ${ip}`,\n                model: `Impressora de Rede (Porta ${port})`,\n                type: 'network',\n                status: 'online',\n                protocol: port === 515 ? 'LPR' : port === 631 ? 'IPP' : 'RAW',\n                discovered: true\n              });\n              break;\n            }\n          }\n        }\n      })()\n    );\n    \n    // Limitar concorr√™ncia para n√£o sobrecarregar\n    if (promises.length >= 30) {\n      await Promise.all(promises);\n      promises.length = 0;\n    }\n  }\n  \n  // Aguardar verifica√ß√µes restantes\n  await Promise.all(promises);\n  \n  return foundPrinters;\n}\n\n// Verificar IP espec√≠fico\nasync function checkSpecificIP(ip: string, ports?: number[]): Promise<any[]> {\n  const portsToCheck = ports || THERMAL_PRINTER_PORTS;\n  const foundPrinters: any[] = [];\n  \n  console.log(`üîç Verificando IP espec√≠fico: ${ip}`);\n  \n  for (const port of portsToCheck) {\n    const isOpen = await checkPort(ip, port, 500);\n    if (isOpen) {\n      console.log(`‚úÖ Impressora encontrada em ${ip}:${port}`);\n      \n      const info = await getPrinterInfo(ip, port);\n      \n      foundPrinters.push({\n        ip,\n        port,\n        name: `Impressora ${ip}:${port}`,\n        model: info?.model || 'Impressora de Rede',\n        type: 'network',\n        status: 'online',\n        protocol: port === 9100 ? 'RAW' : port === 515 ? 'LPR' : port === 631 ? 'IPP' : 'RAW',\n        discovered: true\n      });\n    }\n  }\n  \n  if (foundPrinters.length === 0) {\n    console.log(`‚ùå Nenhuma impressora encontrada em ${ip}`);\n  }\n  \n  return foundPrinters;\n}\n\nexport async function GET(request: Request) {\n  try {\n    const url = new URL(request.url);\n    const quickScan = url.searchParams.get('quick') === 'true';\n    const scanType = url.searchParams.get('type') || 'all';\n    const targetSubnet = url.searchParams.get('subnet'); // Permitir especificar subnet\n    const targetIP = url.searchParams.get('ip'); // Permitir especificar IP\n    \n    console.log(`üîç Iniciando descoberta de impressoras (${quickScan ? 'r√°pida' : 'completa'})...`);\n    \n    const allFoundPrinters: any[] = [];\n    \n    // Se um IP espec√≠fico foi fornecido, verificar apenas ele\n    if (targetIP) {\n      const printers = await checkSpecificIP(targetIP);\n      allFoundPrinters.push(...printers);\n    } else {\n      // Descobrir impressoras de rede\n      if (scanType === 'all' || scanType === 'network') {\n        let subnetsToScan: string[] = [];\n        \n        if (targetSubnet) {\n          // Usar subnet espec√≠fica fornecida\n          subnetsToScan = [targetSubnet];\n        } else {\n          // Usar todas as subnets conhecidas\n          subnetsToScan = getLocalSubnets();\n        }\n        \n        console.log(`üì° Subnets a escanear: ${subnetsToScan.join(', ')}`);\n        \n        // Priorizar subnets comuns\n        const prioritySubnets = ['192.168.86.', '192.168.1.', '192.168.0.'];\n        \n        for (const subnet of prioritySubnets) {\n          if (subnetsToScan.includes(subnet)) {\n            const printers = await scanSubnet(subnet, quickScan);\n            allFoundPrinters.push(...printers);\n          }\n        }\n        \n        // Escanear outras subnets\n        for (const subnet of subnetsToScan) {\n          if (!prioritySubnets.includes(subnet)) {\n            const printers = await scanSubnet(subnet, quickScan);\n            allFoundPrinters.push(...printers);\n          }\n        }\n      }\n    }\n    \n    // Remover duplicatas por IP\n    const uniquePrinters = allFoundPrinters.reduce((acc: any[], printer) => {\n      if (!acc.find(p => p.ip === printer.ip && p.port === printer.port)) {\n        acc.push(printer);\n      }\n      return acc;\n    }, []);\n    \n    console.log(`‚úÖ Descoberta conclu√≠da. ${uniquePrinters.length} impressoras encontradas`);\n    \n    return NextResponse.json({\n      success: true,\n      discovered: uniquePrinters.length,\n      network: uniquePrinters.filter(p => p.type === 'network').length,\n      local: uniquePrinters.filter(p => p.type === 'local').length,\n      printers: uniquePrinters,\n      subnets: targetSubnet ? [targetSubnet] : getLocalSubnets(),\n      scanType,\n      quickScan\n    });\n    \n  } catch (error: any) {\n    console.error('‚ùå Erro na descoberta de impressoras:', error);\n    return NextResponse.json(\n      { \n        success: false, \n        error: error.message || \"Erro ao descobrir impressoras\",\n        details: error.stack\n      },\n      { status: 500 }\n    );\n  }\n}\n\n// POST para escanear um IP espec√≠fico\nexport async function POST(request: Request) {\n  try {\n    const { ip, ports } = await request.json();\n    \n    if (!ip) {\n      return NextResponse.json(\n        { success: false, error: \"IP √© obrigat√≥rio\" },\n        { status: 400 }\n      );\n    }\n    \n    console.log(`üîç Verificando IP espec√≠fico: ${ip}`);\n    \n    const foundPrinters = await checkSpecificIP(ip, ports);\n    \n    return NextResponse.json({\n      success: true,\n      found: foundPrinters.length > 0,\n      printers: foundPrinters,\n      message: foundPrinters.length > 0 \n        ? `‚úÖ ${foundPrinters.length} impressora(s) encontrada(s) em ${ip}`\n        : `‚ùå Nenhuma impressora encontrada em ${ip}. Verifique se est√° ligada e na mesma rede.`\n    });\n    \n  } catch (error: any) {\n    console.error('‚ùå Erro ao escanear IP:', error);\n    return NextResponse.json(\n      { \n        success: false, \n        error: error.message || \"Erro ao escanear IP\"\n      },\n      { status: 500 }\n    );\n  }\n}"],"names":[],"mappings":"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","debugId":null}}]
}