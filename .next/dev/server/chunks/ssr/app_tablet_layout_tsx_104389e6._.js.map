{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/tablet/layout.tsx"],"sourcesContent":["'use client'\n\nimport { useEffect } from 'react'\n\nexport default function TabletLayout({ children }: { children: React.ReactNode }) {\n  useEffect(() => {\n    // Prevenir zoom no tablet\n    const viewport = document.querySelector('meta[name=viewport]')\n    if (viewport) {\n      viewport.setAttribute('content', \n        'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no')\n    }\n\n    // Prevenir menu de contexto (pressão longa)\n    const preventContextMenu = (e: Event) => e.preventDefault()\n    document.addEventListener('contextmenu', preventContextMenu)\n\n    // Prevenir seleção de texto\n    const preventSelection = (e: Event) => e.preventDefault()\n    document.addEventListener('selectstart', preventSelection)\n    \n    // Prevenir scroll bounce no iOS\n    document.body.style.overscrollBehavior = 'none'\n    \n    // Prevenir pull-to-refresh\n    let lastY = 0\n    const preventPullToRefresh = (e: TouchEvent) => {\n      const scrollY = window.pageYOffset || document.documentElement.scrollTop\n      const deltaY = e.touches[0].pageY - lastY\n      \n      if (scrollY === 0 && deltaY > 0) {\n        e.preventDefault()\n      }\n      lastY = e.touches[0].pageY\n    }\n    \n    document.addEventListener('touchstart', (e) => {\n      lastY = e.touches[0].pageY\n    })\n    document.addEventListener('touchmove', preventPullToRefresh, { passive: false })\n    \n    // Manter tela sempre ligada (Wake Lock API)\n    let wakeLock: any = null\n    const requestWakeLock = async () => {\n      try {\n        if ('wakeLock' in navigator) {\n          wakeLock = await (navigator as any).wakeLock.request('screen')\n        }\n      } catch (err) {\n        console.log('Wake Lock não disponível')\n      }\n    }\n    \n    requestWakeLock()\n    \n    // Re-adquirir wake lock quando a página ficar visível novamente\n    document.addEventListener('visibilitychange', () => {\n      if (document.visibilityState === 'visible') {\n        requestWakeLock()\n      }\n    })\n    \n    return () => {\n      document.removeEventListener('contextmenu', preventContextMenu)\n      document.removeEventListener('selectstart', preventSelection)\n      document.removeEventListener('touchmove', preventPullToRefresh)\n      if (wakeLock) {\n        wakeLock.release()\n      }\n    }\n  }, [])\n  \n  return (\n    <div className=\"min-h-screen bg-gray-950 text-white overflow-hidden\">\n      {children}\n    </div>\n  )\n}"],"names":[],"mappings":";;;;;AAEA;AAFA;;;AAIe,SAAS,aAAa,EAAE,QAAQ,EAAiC;IAC9E,IAAA,kNAAS,EAAC;QACR,0BAA0B;QAC1B,MAAM,WAAW,SAAS,aAAa,CAAC;QACxC,IAAI,UAAU;YACZ,SAAS,YAAY,CAAC,WACpB;QACJ;QAEA,4CAA4C;QAC5C,MAAM,qBAAqB,CAAC,IAAa,EAAE,cAAc;QACzD,SAAS,gBAAgB,CAAC,eAAe;QAEzC,4BAA4B;QAC5B,MAAM,mBAAmB,CAAC,IAAa,EAAE,cAAc;QACvD,SAAS,gBAAgB,CAAC,eAAe;QAEzC,gCAAgC;QAChC,SAAS,IAAI,CAAC,KAAK,CAAC,kBAAkB,GAAG;QAEzC,2BAA2B;QAC3B,IAAI,QAAQ;QACZ,MAAM,uBAAuB,CAAC;YAC5B,MAAM,UAAU,OAAO,WAAW,IAAI,SAAS,eAAe,CAAC,SAAS;YACxE,MAAM,SAAS,EAAE,OAAO,CAAC,EAAE,CAAC,KAAK,GAAG;YAEpC,IAAI,YAAY,KAAK,SAAS,GAAG;gBAC/B,EAAE,cAAc;YAClB;YACA,QAAQ,EAAE,OAAO,CAAC,EAAE,CAAC,KAAK;QAC5B;QAEA,SAAS,gBAAgB,CAAC,cAAc,CAAC;YACvC,QAAQ,EAAE,OAAO,CAAC,EAAE,CAAC,KAAK;QAC5B;QACA,SAAS,gBAAgB,CAAC,aAAa,sBAAsB;YAAE,SAAS;QAAM;QAE9E,4CAA4C;QAC5C,IAAI,WAAgB;QACpB,MAAM,kBAAkB;YACtB,IAAI;gBACF,IAAI,cAAc,WAAW;oBAC3B,WAAW,MAAM,AAAC,UAAkB,QAAQ,CAAC,OAAO,CAAC;gBACvD;YACF,EAAE,OAAO,KAAK;gBACZ,QAAQ,GAAG,CAAC;YACd;QACF;QAEA;QAEA,gEAAgE;QAChE,SAAS,gBAAgB,CAAC,oBAAoB;YAC5C,IAAI,SAAS,eAAe,KAAK,WAAW;gBAC1C;YACF;QACF;QAEA,OAAO;YACL,SAAS,mBAAmB,CAAC,eAAe;YAC5C,SAAS,mBAAmB,CAAC,eAAe;YAC5C,SAAS,mBAAmB,CAAC,aAAa;YAC1C,IAAI,UAAU;gBACZ,SAAS,OAAO;YAClB;QACF;IACF,GAAG,EAAE;IAEL,qBACE,8OAAC;QAAI,WAAU;kBACZ;;;;;;AAGP","debugId":null}}]
}