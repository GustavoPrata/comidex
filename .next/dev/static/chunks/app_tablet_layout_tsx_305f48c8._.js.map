{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/tablet/layout.tsx"],"sourcesContent":["'use client'\n\nimport { useEffect } from 'react'\n\nexport default function TabletLayout({ children }: { children: React.ReactNode }) {\n  useEffect(() => {\n    // Prevenir zoom no tablet\n    const viewport = document.querySelector('meta[name=viewport]')\n    if (viewport) {\n      viewport.setAttribute('content', \n        'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no')\n    }\n\n    // Prevenir menu de contexto (pressão longa)\n    const preventContextMenu = (e: Event) => e.preventDefault()\n    document.addEventListener('contextmenu', preventContextMenu)\n\n    // Prevenir seleção de texto\n    const preventSelection = (e: Event) => e.preventDefault()\n    document.addEventListener('selectstart', preventSelection)\n    \n    // Prevenir scroll bounce no iOS\n    document.body.style.overscrollBehavior = 'none'\n    \n    // Prevenir pull-to-refresh\n    let lastY = 0\n    const preventPullToRefresh = (e: TouchEvent) => {\n      const scrollY = window.pageYOffset || document.documentElement.scrollTop\n      const deltaY = e.touches[0].pageY - lastY\n      \n      if (scrollY === 0 && deltaY > 0) {\n        e.preventDefault()\n      }\n      lastY = e.touches[0].pageY\n    }\n    \n    document.addEventListener('touchstart', (e) => {\n      lastY = e.touches[0].pageY\n    })\n    document.addEventListener('touchmove', preventPullToRefresh, { passive: false })\n    \n    // Manter tela sempre ligada (Wake Lock API)\n    let wakeLock: any = null\n    const requestWakeLock = async () => {\n      try {\n        if ('wakeLock' in navigator) {\n          wakeLock = await (navigator as any).wakeLock.request('screen')\n        }\n      } catch (err) {\n        console.log('Wake Lock não disponível')\n      }\n    }\n    \n    requestWakeLock()\n    \n    // Re-adquirir wake lock quando a página ficar visível novamente\n    document.addEventListener('visibilitychange', () => {\n      if (document.visibilityState === 'visible') {\n        requestWakeLock()\n      }\n    })\n    \n    return () => {\n      document.removeEventListener('contextmenu', preventContextMenu)\n      document.removeEventListener('selectstart', preventSelection)\n      document.removeEventListener('touchmove', preventPullToRefresh)\n      if (wakeLock) {\n        wakeLock.release()\n      }\n    }\n  }, [])\n  \n  return (\n    <div className=\"min-h-screen bg-gray-950 text-white overflow-hidden\">\n      {children}\n    </div>\n  )\n}"],"names":[],"mappings":";;;;;AAEA;;;AAFA;;AAIe,SAAS,aAAa,EAAE,QAAQ,EAAiC;;IAC9E,IAAA,0KAAS;kCAAC;YACR,0BAA0B;YAC1B,MAAM,WAAW,SAAS,aAAa,CAAC;YACxC,IAAI,UAAU;gBACZ,SAAS,YAAY,CAAC,WACpB;YACJ;YAEA,4CAA4C;YAC5C,MAAM;6DAAqB,CAAC,IAAa,EAAE,cAAc;;YACzD,SAAS,gBAAgB,CAAC,eAAe;YAEzC,4BAA4B;YAC5B,MAAM;2DAAmB,CAAC,IAAa,EAAE,cAAc;;YACvD,SAAS,gBAAgB,CAAC,eAAe;YAEzC,gCAAgC;YAChC,SAAS,IAAI,CAAC,KAAK,CAAC,kBAAkB,GAAG;YAEzC,2BAA2B;YAC3B,IAAI,QAAQ;YACZ,MAAM;+DAAuB,CAAC;oBAC5B,MAAM,UAAU,OAAO,WAAW,IAAI,SAAS,eAAe,CAAC,SAAS;oBACxE,MAAM,SAAS,EAAE,OAAO,CAAC,EAAE,CAAC,KAAK,GAAG;oBAEpC,IAAI,YAAY,KAAK,SAAS,GAAG;wBAC/B,EAAE,cAAc;oBAClB;oBACA,QAAQ,EAAE,OAAO,CAAC,EAAE,CAAC,KAAK;gBAC5B;;YAEA,SAAS,gBAAgB,CAAC;0CAAc,CAAC;oBACvC,QAAQ,EAAE,OAAO,CAAC,EAAE,CAAC,KAAK;gBAC5B;;YACA,SAAS,gBAAgB,CAAC,aAAa,sBAAsB;gBAAE,SAAS;YAAM;YAE9E,4CAA4C;YAC5C,IAAI,WAAgB;YACpB,MAAM;0DAAkB;oBACtB,IAAI;wBACF,IAAI,cAAc,WAAW;4BAC3B,WAAW,MAAM,AAAC,UAAkB,QAAQ,CAAC,OAAO,CAAC;wBACvD;oBACF,EAAE,OAAO,KAAK;wBACZ,QAAQ,GAAG,CAAC;oBACd;gBACF;;YAEA;YAEA,gEAAgE;YAChE,SAAS,gBAAgB,CAAC;0CAAoB;oBAC5C,IAAI,SAAS,eAAe,KAAK,WAAW;wBAC1C;oBACF;gBACF;;YAEA;0CAAO;oBACL,SAAS,mBAAmB,CAAC,eAAe;oBAC5C,SAAS,mBAAmB,CAAC,eAAe;oBAC5C,SAAS,mBAAmB,CAAC,aAAa;oBAC1C,IAAI,UAAU;wBACZ,SAAS,OAAO;oBAClB;gBACF;;QACF;iCAAG,EAAE;IAEL,qBACE,6LAAC;QAAI,WAAU;kBACZ;;;;;;AAGP;GAzEwB;KAAA","debugId":null}}]
}